# 校验注解的使用方式

## 前言

- ```@Min```: 验证 ```Number``` 和 ```String``` 类型的值是否大等于指定的值
- ```@Max```: 验证 ```Number``` 和 ```String``` 类型的值是否小等于指定的值
- ```@Size(min=, max=)```: 验证对象（```Array,Collection,Map,String```）长度是否在给定的范围之内。完整包名是 ```javax.validation.constraints.Size```
- ```@Length(min=, max=)```: 验证 ```String``` 类型长度是否在给定的范围之内。完整包名是 ```org.hibernate.validator.constraints.Length```

注意:

- ```@Max``` 和 ```@Min``` 注解是对输入的"数字"是否大于或小于指定值，这个"数字"可以是 number 或者 string 类型
- 长度限制使用 ```@Length``` 注解
- 由于 ```@Size``` 可适用各种类型的长度验证， 具有通用性，推荐使用。

## 添加依赖

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-validation</artifactId>
</dependency>
```

## ```@Valid``` 和 ```@Validated``` 比较

- 相同点:
   ```@Valid``` 注解和 ```@Validated``` 注解都是开启校验功能的注解

- 不同点:
   - ```@Validated``` 注解是 Spring 基于 ```@Valid``` 注解的进一步封装，并提供比如分组、分组顺序等高级功能
   - ```@Valid``` 注解 : 可以使用在方法、构造函数、方法参数和成员属性上
   - ```@Validated``` 注解 : 可以用在类型、方法和方法参数上. 但是不能用在成员属性上

使用方式:

1. 在 controller 层的 ```方法参数``` 上开启 ```@Validated``` 或 ```@Valid```
2. 在 model 层的 ```属性``` 上添加约束性注解
3. 级联校验在嵌套的对象上使用 ```@Valid```

## 普通用法

```java
@Data
public class User {
    @NotNull(message = "age 不能为空")
    private Integer age;
    @Size(min = 2, max = 6, message = "name 长度必须在 2 - 6 之间")
    private String name;
}

@PostMapping("/user")
public void user(@RequestBody @Validated User user) {
    System.out.println(user);
}
```

## 高级用法

### ```@Valid``` 级联校验

级联校验也叫嵌套校验，嵌套就是一个类包含另一个类的对象。

只是在方法参数前面添加 ```@Valid``` 或 ```@Validated``` 注解，不会对嵌套的实体对象进行校验。要想实现对嵌套的实体对象进行校验，需要在嵌套的实体对象上添加 ```@Valid``` 注解。

示例:

```java
@Data
public class Address {
    @Size(min = 2, max = 6, message = "province 长度必须在 2 - 16 之间")
    private String province;
    @Size(min = 2, max = 6, message = "city 长度必须在 2 - 10 之间")
    private String city;
}

@Data
public class User {
    @NotNull(message = "age 不能为空")
    private Integer age;
    @Size(min = 2, max = 6, message = "name 长度必须在 2 - 6 之间")
    private String name;
    @Valid
    @NotNull(message = "address 不能为空")
    private Address address;
    @Valid
    @NotEmpty(message = "addressList 不能为空")
    private List<Address> addressList;
}

@PostMapping("/user")
public void user(@RequestBody @Validated User user) {
    System.out.println(user);
}
```

非空校验的注解:

- 单个对象使用 ```@NotNull```
- List对象使用 ```@NotEmpty```

### ```@Validated``` 分组校验

分组校验，对指定的组开启校验，可以分别作用于不同的业务场景。

1. 由约束性注解中的分组方法 ```groups``` 指定分组
2. 由 ```@Validated``` 注解中的 ```value``` 方法对指定的分组开启校验

示例:

```java
@Data
public class Address {
    @Size(min = 2, max = 6, message = "province 长度必须在 2 - 16 之间")
    private String province;
    @Size(min = 2, max = 6, message = "city 长度必须在 2 - 10 之间")
    private String city;
}

@Data
public class User {
    public interface Add {
    }

    public interface Update {
    }

    @NotNull(message = "age 不能为空")
    private Integer age;
    @Size(min = 2, max = 6, message = "name 长度必须在 2 - 6 之间")
    private String name;
    @Valid
    @NotNull(message = "address 不能为空", groups = {Add.class, Update.class})
    private Address address;
    @Valid
    @NotEmpty(message = "addressList 不能为空", groups = {Add.class})
    private List<Address> addressList;
}

@PostMapping("/user")
public void add(@RequestBody @Validated(value = User.Add.class) User user) {
    System.out.println(user);
}

@PutMapping("/user")
public void update(@RequestBody @Validated(value = User.Update.class) User user) {
    System.out.println(user);
}
```

### ```@GroupSequence``` 分组校验顺序

默认情况下，分组间的约束是无序的，但是在一些特殊的情况下可能对分组间的校验有一定的顺序。分组校验顺序通过使用 ```@GroupSequence``` 注解实现。

使用 ```@GroupSequence``` 注解指定分组校验顺序后，如果第一组分组的约束校验没有通过，就不会进行第二组分组的约束校验。

示例:

```java
@Data
public class User {
    public interface First {
    }

    public interface Second {
    }

    @GroupSequence({First.class, Second.class})
    public interface Sequence {
    }

    @NotNull(message = "age 不能为空", groups = Second.class)
    private Integer age;
    @Size(min = 2, max = 6, message = "name 长度必须在 2 - 6 之间", groups = First.class)
    private String name;
}

@PostMapping("/user")
public void add(@RequestBody @Validated(value = User.Sequence.class) User user) {
    System.out.println(user);
}
```

### ```@Validated``` 普通变量校验

在类上添加 ```@Validated``` 注解开启普通变量校验。

```java
@RestController
@Validated
public class UserController {
    @GetMapping("/user")
    public void get(@RequestParam @Range(min = 3, max = 8, message = "年龄在3 - 8岁！") int age){
        System.out.println(age);
    }
}
```

### 自定义约束注解

```java
@Target({ElementType.METHOD, ElementType.FIELD, ElementType.ANNOTATION_TYPE, ElementType.CONSTRUCTOR, ElementType.PARAMETER, ElementType.TYPE_USE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Constraint(
        validatedBy = {MobileValidator.class}
)
public @interface Mobile {
    String message() default "wrong mobile number.";

    Class<?>[] groups() default {};

    Class<? extends Payload>[] payload() default {};
}

public class MobileValidator implements ConstraintValidator<Mobile, String> {
    private Pattern mobilePattern = Pattern.compile("1\\d{10}");

    @Override
    public boolean isValid(String value, ConstraintValidatorContext context) {
        if (StringUtils.isEmpty(value)) {
            return false;
        }
        Matcher matcher = mobilePattern.matcher(value);
        return matcher.matches();
    }
}

@Data
public class User {
    @NotNull(message = "age 不能为空")
    private Integer age;
    @Size(min = 2, max = 6, message = "name 长度必须在 2 - 6 之间")
    private String name;
    @Mobile
    private String mobile;
}
```

## 全局统一异常处理

```java
@RestControllerAdvice
public class ExceptionHandlerAdvice {
    /**
     * 通用异常处理
     */
    @ExceptionHandler(Exception.class)
    public Result<Void> exceptionHandler(Exception e) {
        return ResultUtil.error(-1, e.getMessage());
    }

    /**
     * 参数校验结果异常处理
     */
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public Result<Void> methodArgumentNotValidExceptionHandler(MethodArgumentNotValidException e) {
        BindingResult bindingResult = e.getBindingResult();
        FieldError fieldError = bindingResult.getFieldError();
        assert fieldError != null;
        return ResultUtil.error(-1, fieldError.getField() + " : " + fieldError.getDefaultMessage());
    }

    /**
     * 参数校验过程异常处理
     */
    @ExceptionHandler(ValidationException.class)
    public Result<Void> validationExceptionHandler(ValidationException e) {
        return ResultUtil.error(-1, e.getMessage());
    }

    @ExceptionHandler
    public Result<Void> handle(ConstraintViolationException exception) {
        Set<ConstraintViolation<?>> violations = exception.getConstraintViolations();
        StringBuilder builder = new StringBuilder();
        for (ConstraintViolation violation : violations) {
            builder.append(violation.getMessage());
        }
        return ResultUtil.error(-1, builder.toString());
    }
}

```
